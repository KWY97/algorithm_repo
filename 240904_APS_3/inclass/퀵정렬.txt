<퀵정렬>
 주어진 배열을 두 개로 분할하고, 각각을 정렬한다.
 퀵 정렬은 Partitioning 이라는 과정을 반복하면서, 평균 시간복잡도 O(n log n) 속도라는 빠른 속도로 정렬이 되는 Sort이다.
 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘이다.

 병합 정렬과 다른점
  1. 병합 정렬은 그냥 두 부분으로 나누는 반면에, 퀵 정렬은 분할할 때, 기준 아이템을 중심으로 분할한다.
     기준보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
  2. 각 부분 정렬이 끝난 후, 병합정렬은 '병합'이란 후처리 작업이 필요하나, 퀵 정렬은 필요로 하지 않는다. (퀵 정렬은 대신 swap이 많이 발생한다.)

!!! Partitioning: 작업 1회 - pivot의 위치를 확정 짓는다. !!! - 시험삘 (그림, 과정)
  1. 작업영역을 정한다.
  2. 작업영역 중 가장 왼쪽에 있는 수를 Pivot 이라고 하자. (Pivot을 '기준'으로 해석한다.)
     (퀵 정렬은 기준을 어디로 잡냐에 따라 성능이 많이 차이남)
  3. Pivot을 기준으로 왼쪽에는 Pivot 보다 작은 수를 배치한다. (정렬안됨)
     Pivot을 기준으로 오른쪽에는 Pivot 보다 큰 수를 배치시킨다. (정렬안됨)

  -> 파티셔닝이 끝나고 Pivot의 위치는 확정(Fix)된다.
     (즉, 최종 정렬이 끝나고 Pivot의 위치는 지금 위치 그대로 배정)

  그 후 이제 Pivot을 기준으로 왼쪽 or 오른쪽에 작업영역을 정하고 1~3 과정을 동일하게 진행

 Pivot 선택에 따라 장단점이 달라지고 데이터에 따라 선택해야 하는 기준또한 다양하다.
 ex) Pivot을 맨 왼쪽으로 잡으면 편하고 간단하다.
     단점: 역순 정렬되어 있을 때 O(N**2)의 시간 복잡도가 나옴

 Hoare-Partition 알고리즘: 교재랑 예시 코드 보기.
  Pivot 보다 큰 값은 오른쪽, 작은 값들은 왼쪽 집합에 위치하도록 한다.
  Pivot을 두 집합의 가운데 위치시킨다.
  i는 왼쪽부터 시작해서 Pivot 보다 큰 값 만나고
  j는 오른쪽부터 시작해서 Pivot 보다 작은 값 만나면
  서로 위치 교환

 Lomuto_Partition 알고리즘: Hoare보다 느리다. 그냥 알고만 넘어가면 댐 (swap이 더 많이 발생하기 때문)
  - 우측을 Pivot으로 잡음 (for문 돌리기 편해서 그런 것, 왼쪽으로 잡아도됨)
  - i = -1, j= 0 부터 시작
  - j가 Pivot 보다 큰 값 만나면 i만 정지
  - Pivot 보다 작은 값 만나면 j가 정지
  - i, j 바꿔주기
  - 반복

 !!! 퀵 정렬은 '평균적'으로 매우 빠르다 !!!
  - 평균:O(n log n) (partitioning 작업에 n번, 분할 작업에 log n번 걸림)
  - 최악: O(N**2) (최악의 경우 분할 작업이 n번 걸리기 때문에 최악은 O(N**2) 인 것)