<SW 문제 해결 역량>
 - 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을
   연결하여 큰 그림을 만드는 능력
 - 반복 훈련이 필요 (무작정 암기 X)

 - 문제 해결 과정 (최대한 이 방식에 맞춰서 연습해야 함)
   - 문제를 읽고 이해
   - 문제를 익숙한 용어로 재정의
   - !! 어떻게 해결할지 계획(자료구조, 알고리즘 선택 등)을 세우기 !!
   - !! 계획 검증하기 (손코딩) !!
   - 프로그램으로 구현, 디버깅
   - 어떻게 풀었는지 돌아보고, 개선 방법 찾기

!!! <복잡도 분석> !!! - 중요
 - 알고리즘: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. (어떠한 문제를 해결하기 위한 절차)
   - 알고리즘의 효율
     - 공간적 효율성과 시간적 효율성
       - 공간적 효율성: 연산량 대비 얼마나 '적은 메모리 공간'을 요하는가
       - 시간적 효율성: 연산량 대비 얼마나 '적은 시간'을 요하는가
     - 효율성을 뒤집어 표현하면 복잡도(complexity)가 되며, 복잡도가 높을수록 효율성은 떨어짐

 - '입력 크기 n이 무한대로 커질 때'의 복잡도를 간단히 표현하기 위해 사용하는 표기법들
  - !!! Big-oh -> 최대 시간 (코테에서 많이 강조) !!!
  - Big-omega -> 최소 시간 (실제 개발에서 많이 강조)
  - Big-Theta -> 평균 시간 (실제 개발에서 많이 강조)

  - Big-oh
   - 복잡도의 점근적 상한을 나타낸다
   - n이 무한대로 커진다고 가정하므로 배수나 다른 항들을 버리고 최고차항만 고려
   - 상수 횟수 반복하는 코드는 O(1)이다. 최고차항이 0이기 때문에

   - 예외: 논문 등 알고리즘 성능을 미세하게 비교하고 싶은 경우 배수를 적기도 함.
     (ex. 기존 알고리즘 성능은 O(7N)이지만 제가 만든 알고리즘 성능은 O(2N)입니다.)

   O(log N)은 O(1) 보다는 느리지만, 유사한 성능을 보인다고 결론을 낼 수 있다.
   O(N log N)은 O(N) 보다는 느리지만, 유사한 성능을 보인다고 결론을 낼 수 있다.

   효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.

