<온라인 수업>
<큐>
 - 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
 - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조 (선입선출구조(FIFO: First In First Out))
 - 큐의 기본 연산 -> 삽입: enQueue, 삭제: deQueue

 - 큐의 주요 연산
  1) enQueue(item): 큐의 뒤쪽(rear)에 원소를 삽입하는 연산
  2) deQueue(): 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
  3) createQueue(): 공백 상태의 큐를 생성하는 연산
  4) isEmpty(): 큐가 공백상태인지를 확인하는 연산 (front == rear 이면 공백상태)
  5) isFull(): 큐가 포화상태인지를 확인하는 연산 (rear == n-1 이면 포화상태, n은 배열의 크기)
  6) Qpeek(): 큐의 앞쪽(front)에서 원소를 삭제없이 반환하는 연산

 - 큐의 연산 과정 - 그림으로도 잘 기억하고, 말로도 잘 기억하기 (교재 6~7p)

 - 선형 큐 이용시의 문제점
    - 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고,
      rear = n-1인 상태 즉, 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨

    - 해결방법 1: 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동시킴
                 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐

    - 해결방법 2: 원형큐

<원형 큐>
 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용
    - 사용방법
        초기 공백 상태: front = rear = 0
        index의 순환: front와 rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킨 후, 그 다음에는 논리적 순환을 이루어
                     배열의 처음 인덱스인 0으로 이동해야 함. (이를 위해 나머지 연산자 mod를 사용함)

        front 변수: 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
        삽입위치: rear = (rear + 1) mod n, 삭제 위치: front = (front + 1) mod n
        (front == rear 이면 공백상태)
        ((rear + 1) mod n == front 이면 포화 상태)


<참고 - deque(덱)>
 deque 객체
  양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너

  사이즈가 큰 큐를 만들 때 덱을 쓰면 편하다. 속도도 빠름.
  크기에 제한도 없다.

 from collection import deque

 q = deque()
 q.append(1) # enqueue()
 t = q.popleft() # dequeue()


<우선순위 큐 (Priority Queue)> - 가볍게 한 느낌
 - 우선순위를 가진 항목들을 저장하는 큐
 - FIFO 순서가 아니라 "우선순위가 높은 순서대로 먼저 나가게 된다."
 - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
 (모든 원소를 우선순위에 따라 정렬해 저장하는게 아닌 현재 상태에서 우선순위가 가장 높은 것을 앞으로 보내놓는 것)


<큐의 활용: 버퍼(buffer)>
 - 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
 - 버퍼링: 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작

 - 버퍼의 자료 구조
  - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용
  - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용됨



<오프라인 수업>
 큐는 !!선입선출!!구조, 스택은 !!후입선출!!
 선형 큐
  공백 큐 만들 때 front = rear = -1 굳이 안해도됨 그냥 front = rear인게 핵심이지 숫자는 원하는 거 해도된다고 함
 구조를 이해하는게 지금의 핵심이지 숫자를 외울 필요는 없다고 함

 원형 큐
  !!공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠!!
  그렇기 때문에 (rear + 1) % n == front 이면 포화상태, rear == front이면 공백상태

  큐 부분은 교재에 있는 enQueue, deQueue, isEmpty, isFull, Qpeek 함수 직접 구현해보는 정도로 공부하면 댄다.
  교재의 함수가 정답이 아님. 구조를 이해하고 자신이 구현할 수 있으면 되는 것임.
  (인덱스 순환하는 부분을 제대로 구현하는게 가장 중요함!)

  연결 큐
    단순 연결 리스트를 이용한 큐
    연결 리스트를 배우는 이유: 일반 리스트의 데이터 삽입, 삭제하는 시간 복잡도: O(n)이고, 공간도 미리 할당해놓고 사용해야하기에 동적이지 않다.
               연결리스트는 동적이기 때문에 이를 해결할 수 있음. 하지만 시간 복잡도: O(n)이다. 중간에 데이터를 삽입하는 행위 자체는 O(1)이지만
               삽입을 하기위해 삽입 위치를 찾는 과정이 O(n)인 것.

    단순 연결리스트와 이중 연결리스트 있음.
    장점
    메모리가 동적 관리 (메모리 낭비가 별로 없다. 필요한 개수만큼만 쓰니까)
    삽입 시 처음과 끝에서는 O(1)

    단점
    단순 연결리스트는 역방향 탐색이 안된다. -> 이중은 가능
    탐색이 O(n)이다


  !!deque!! - 우리가 많이 쓸 것이라고 함
  이중연결리스트이다.

  단점
   슬라이싱이 안된다.
   정렬이 어렵다.
   인덱스 접근이 어렵다. (de_q[idx]로 접근하면 시간복잡도가 O(n)임)