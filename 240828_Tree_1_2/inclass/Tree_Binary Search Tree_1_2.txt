<이진 탐색 트리 (BST, Binary Search Tree)> - 데이터 탐색, 추가, 삭제에 매우 효율적
- Data들을 빠르게 검색할 수 있도록 '체계적으로 저장'을 해 두고, 최대 'O(log n)의 빠른 속도'로 값을 검색할 수 있는 구조
*) 개발 분야에서 log의 밑은 10이 아닌 2이다.

- 빠르게 검색될 수 있도록, 특정 규칙을 갖는 이진트리 형태로 값을 저장해 둔다.

<리스트 VS BST> - BST는 리스트보다 더 빠른 삽입/ 삭제/ 탐색이 가능하다.
- 리스트 성능
 - 삽입: O(n), 단 맨 끝 삽입은 O(1) - n에 비례해서 시간이 증가한다.
 - 삭제: O(n), 단 맨 끝 삭제은 O(1) - n에 비례해서 시간이 증가한다.
 - 탐색: O(n)

- BST 성능 (무조건 항상 좋다 X, !!평균!! 소요시간이 좋다. - 주의)
   탐색, 삽입, 삭제 시간은 트리의 높이 만큼 시간이 걸린다.
   (높이 h: log N(완전이진탐색) ~ N(편향))

 - 삽입: 평균 O(log N), 정렬이 되어 있는 경우(최악의 경우) O(N)
 - 삭제: 평균 O(log N)
 - 탐색: 평균 O(log N)

*) 파이썬 공식 Library에는 BST 자료구조가 내장되어 있지 않아 직접 구현해서 사용해야 한다.
(자바 등 다른 언어는 Library에 있다고 함)

<삽입, 탐색>
 !! target 값이 부모노드보다 크거나 같으면 오른쪽, 작거나 같면 왼쪽에 삽입 !! (오른쪽에 넣는게 더 나음, 왼쪽에 넣으면 부모 노드보다 큰 값은 모두 오른쪽으로 가서 이진 편향 트리가 됨)
 삽입을 위해, root 부터 바닥 노드까지 탐색을 하며 자기 위치를 찾는다.
 이는 트리의 높이(h)만큼 탐색 시간이 걸린다.

<순회>
- BST에서 DFS 중위순회를 하게 되면 Key 값이 작은 순서대로 탐색이 가능하다.
(BST는 작은걸 왼쪽에 넣는 것이고, 중위 순회는 왼쪽부터 읽는 것이기 때문에)

<삭제> - BST 규칙을 유지해야 한다.
1. 리프노드 삭제 -> 그냥 삭제해도 BST 규칙 유지된다.
2. 삭제할 노드의 자식이 하나 -> 자식을 삭제할 노드의 부모로 !! 먼저 연결 !! 해주고 삭제할 노드 삭제
3. 삭제할 노드의 자식이 2개 일 때 ->  1) 삭제할 노드의 왼쪽 서브트리의 가장 큰 값
                                  2) 삭제할 노드의 오른쪽 서브트리의 가장 작은 값
                                  둘 중 상황에 맞는 하나를 골라 삭제할 노드에 값을 복사해주고 실제 값은 삭제

삭제 연산은 자식의 개수에 따라 다르게 동작한다.
지우려고 하는 노드를 탐색한 후 삭제하기 때문에 시간 복잡도가 log N임. 삭제하는건 상수 시간이고, 탐색 때문에 log N의 시간 복잡도를 가지는 것

<정리>
탐색작업을 효율적으로 하기 위한 구조
모든 원소는 서로 다른 유일한 키를 갖는다. (문제마다 다를 수 있다. 같은 키를 가질수도)
key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다.
중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.



