<힙 (heap)> - A형 준비할 때도 많이 활용! (지금은 BST보다 오히려 더 중요)
- '완전 이진 트리'에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 형제 노드는 신경 쓸 필요 X

- 최대 힙: 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - !! 부모 노드의 키 값 > 자식 노드의 키 값 !!
  - 루트 노드: 키 값이 가장 큰 노드

  <최소 힙은 아래 삽입, 삭제 과정에서 큰 값, 작은 값 반대로 하면 되는 것>
  - 삽입 -> N개의 데이터 전체에 대해 시간 복잡도 O(N * log N), 한 번 한번의 연산은 시간 복잡도: O(log N)
   1. 일단 맨 뒤에 삽입 (중간에 넣으면 깨지기 때문)
   2. 부모보다 내가 작다면 끝
   3. 부모보다 내가 크다면 부모와 자리바꿈
   4. 2~3 계속 하며 위치 찾아감 (비교, swap 사용됨)

   *) 형제 끼리는 보장이 안되기 때문에 리스트로 디버깅 시 주의해야 한다.
   *) 리스트에 있다고 칠 때 부모 노드(n)과 왼쪽자식(2n), 오른쪽 자식(2n+1) 이렇게 3개 비교해서 부모 노드가 가장 크면 잘된 것

  - 삭제 -> N개의 데이터 전체에 대해 시간 복잡도 O(N * log N), 한 번 한번의 연산은 시간 복잡도: O(log N)
   1. 마지막 노드를 루트 노드에 넣고 마지막 노드 삭제 (마지막 노드랑 루트 노드 값 교환하고 마지막 노드 삭제하는 것)
   2. 자식 둘 보다 바뀐 루트 노드가 크다면 끝
   3. 그렇지 않다면 자식 노드 둘을 비교한 후 더 큰 값과 교체


- 최소 힙: 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - !! 부모노드의 키 값 < 자식 노드의 키 값 !!
  - 루트 노드: 키 값이 가장 작은 노드

  - 삽입 (live code 보기)
    1. 일단 맨 뒤에 삽입
    2. 부모보다 내가 크다면 끝
    3. 부모보다 내가 작다면 부모와 자리바꿈
    4. 2~3 계속 하며 위치 찾아감 (비교, swap 사용됨)

  - 삭제 (live code 보기)
    1. 마지막 노드를 루트 노드에 넣고 마지막 노드 삭제
    2. 자식 둘 보다 바뀐 루트 노드가 작다면 끝
    3. 그렇지 않다면 자식 노드 둘을 비교한 후 더 작은 값과 교체

<힙 정리>
- 완전 이진 트리로 구현된 자료구조로서, '키 값이 가장 큰 노드'나 '키 값이 가장 작은 노드'를 찾기에 적합한 자료구조
- 힙의 키를 우선순위로 활용하여 !! '우선순위 큐' !!를 구현할 수 있다. - 매우 매우 중요

- 내장함수 있음

- lectures에 .py 파일들 보면서 공부


