카운팅 정렬
 - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
 - 제한 사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.
 - 시간 복잡도
    - O(n+K): n은 리스트길이, k는 정수의 최댓값

카운팅 정렬 과정 (교재 40p~) - 오늘의 첫 번째 목표: 1,2단계 까지 이해하고 구현하기
 - 1단계: Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
	(1. Data의 숫자 개수(ex 0~4까지면 N은 5)가 N일 때(인덱스는 0 ~ N-1), '[0] * N'을 활용해 해당 크기의 빈 리스트인 counts 먼저 생성)
	(2. counts[i] = i 의 발생 회수가 되게 count[0] += 1 이런식으로 전체 원소를 돌아야함)
	값으로 부르는 예시 for x in Data:                   인덱스로 부르는 예시 for i in range(0, len(Data)):
	                             counts[x] += 1                                             counts(Data[i]) += 1

 - 2단계: 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
	(1. 0은 가장 작은 숫자니까 그대로 둠)
	(2. 1보다 작은 숫자(0)들의 개수(count[0]) 구하고 더하기, 2보다 작은 숫자들의 개수 구하고 더하기, ... , N-1보다 작은 숫자들의 개수 구하고 더하기)


 - 3단계: 1단계, 2단계로 나온 결과를 가지고 정렬 - 교재 42p 보면서 예시 보면서 다시 해보기
    - 정렬된 결과를 저장하는 배열 Temp를 만듬 ( 크기는 N으로 동일)
    - DATA 의 가장 마지막 원소가 i(== DATA[N-1])라면 counts[i]를 찾아감 
    - counts[i]을 1 감소시키고 Temp의 인덱스 번호 (counts[i]-1)에 i를 삽입
    - 모든 원소에 대해 반복

3단계 확실히 적은지 모르겠으니 직접 해보면서 고칠거 잇나 확인

교재 page 50 에서 배열의 크기는 N이라고 보면댐. 시간 복잡도는 5N+2K (1단계: N번, N번/ 2단계: K번, K번/ 3단계: N번, N번, N번)

*) 팁: 반복문 쓸 때 값을 가져올 땐 'i', 'j' 쓰지 말 것. i, j 는 인덱스를 불러올 때 보통 쓰는 것임. (값 불러올 거면 'x' 쓰는 것 괜찮)
*) 3단계 까지 구현이 어려우면 1, 2단계 잘 이해하고 구현하고 버블 정렬과 카운팅 정렬의 장단점 잘 기억하기 (버블 정렬은 시간이 오래걸린다는 단점가짐, 따로 장단점 찾아보기)


완전 검색
 - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
 - 일반적으로 경우의 수가 상대적으로 작을 때 유용함
 - 모든 경우의 수에 대해 테스트 하기에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
     - 우선 완적 검색으로 접근해 해답 도출 후, 성능 개선을 위해 다른 알고리즘 사용하고 해답 확인하는 것이 바람직 (완전 검색만 하면 효율성이 떨어질 수 있음, 그런데 IM, A형은 완전 검색해도 무리없다고 함)

 - 순열 -> 58p개념 보고, 59p 예시 한 번 안보고 해보기([arr]로 빈리스트 만들고 해서 해보기?) -> 순열은 뒷부분에 나오는데 지금 대충 개념만 익혀놓기


탐욕 알고리즘 (탐욕 기법, Greedy)
 - 최적해를 구하는 데 사용되는 근시안적인 방법
 - 여러 경우 중 하나를 결정해야 할 때마다 '그 순간에 최적이라고 생각되는 것을 선택'해 나가는 방식으로 진행하여 최종적인 해답 도출
 - 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었을 때 그것이 최적이라는 보장은 없음
 - 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 됨

 - 과정 (교재 61p 보고 적기)
     - 1. 해 선택
     - 2. 실행 가능성 검사
     - 3. 해 검사

 - 탐욕 알고리즘 풀이 (교재 64p) 해보기 -> 강의 다시보기, 이거 보고 68p 강의 이어 보자 구현하는거니까 (꼭 봐라 저녁이라고 안보지 말고 나 자신아)
   *) run부터 찾으면 triplet 못 찾는 경우가 있으니 triplet먼저 찾자 -> 이거 무슨소린지 이해하기
   *) 입력이 444345 처럼 붙어서 들어오는 경우 배열에 어떻게 저장해야할까?
      DATA = list(map(int, input())) 이렇게 하면 됨

        run은 counts[i], counts[i+1], counts[i+2]가 모두 1이상 이라면 O
        2 2 2 일수도 있으니 그 자리에서 다시 비교 시작 -> 혹시 run이 2개 나오면 끝.
        
        triplet은 counts[i]가 3이상이라면 O
        6 일수도 있으니 그 자리에서 다시 비교 시작 -> 혹시 triplet이 2개 나오면 끝

67p 구현 예 이해하기 - 반드시 알아야 한다고함 - 직접 해보기 꼭

for 문에서 continue 하면 i값 어케되는지 알아보자


























