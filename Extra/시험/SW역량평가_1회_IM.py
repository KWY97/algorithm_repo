# 내 기억
# 스위치의 최종 결과 주어지고 그 스위치가 되기 위한 최소 횟수 찾는 문제
# 조건: 스위치 번호가 있는데 i번째 스위치 조작하면 그 배수들 까지 다 조작된다.

def multiple(num): # num의 배수를 찾는 함수
    mul_li = [] # 배수를 담을 리스트
    for i in range(1, N+1): # i는 1 ~ N
        if i % num == 0: # i 가 num으로 나누어 떨어지면 (ex) 4 % 2 == 0, 4는 2의 배수)
            mul_li.append(i) # i는 num의 배수이므로 li에 추가
    return mul_li # 리스트 형식으로 배수를 리턴해준다. 왜? 바로 for문으로 받아서 돌리려고 (line 19)

T = int(input())
for tc in range(1, T+1):
    N = int(input()) # led 버튼의 개수 이자 led 배열의 길이. ( 하지만 난 제로패딩 했으므로 led 배열의 길이는 N + 1)
    led = [0] + list(map(int, input().split())) # 스위치 번호랑 인덱스 번호 맞추려고 제로 패딩
    start = [0] * (N+1) # led를 제로패딩해서 N+1 길이가 됐기에 초기 상태 역시 길이를 맞춰주기 위해 N+1의 길이 가짐
    cnt = 0
    on_off = [1, 0]

    while led != start: # 최종 목표(입력 값)와 초기상태(0으로 채워진 것)가 같지 않는 동안 돌아간다. (= 같아질 때 까지 돌리겠다.)
        # 모든 스위치에 접근 할것이니 for 문 이용.  근데 제로 패딩 했으므로 인덱스 번호와 스위치 번호가 같다.
        for i in range(1, N+1): # 따라서 i는 1번 ~ N번 스위치 까지 볼것이다.
            if led[i] != start[i]: # 만약에 led의 i번 스위치의 상태와 start의 i번 스위치의 상태가 다르다면
                cnt += 1 # 카운트를 하나 올리고 (왜냐하면 i번 스위치와 그 배수인 스위치 전체를 바꾸는데 그 작업 전체를 카운트 한번으로 보니까 cnt += 1만 하기)
                for j in multiple(i): # 배수 스위치들을 바꾸는 작업을 할 것인데. multiple(i)는 i를 포함한 i의 배수를 리스트로 반환해준다.
                    # 예를 들어 N이 5, i가 2 라면 multiple(i) 의 반환값은 [2, 4]가 된다.
                    # 그러면 for j in [2, 4]로 봐도 되는 것. 그럼 j에는 2가 담기고 그 후 4가 담긴다.
                    # 이제 2, 4 예시는 그만 잊고 다시 본론으로 ... !!
                    # 그렇게 배수 스위치 리스트를 확인하면서 1이면 0으로 0이면 1로 상태를 바꿔줘야 한다. (배수 스위치 리스트에는 i 자신도 포함)
                    # if start[j] == 0: start[j] = 1 # 해당 스위치가 0이면 1로.
                    # else: start[j] = 0 # 1이면 0으로
                    start[j] = on_off[start[j]] # 해당 스위치가 0이면 1로, 1이면 0으로

    print(f'#{tc} {cnt}') # 끝~!!