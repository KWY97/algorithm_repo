<온라인>
2차원 배열
 - 1차원 List를 묶어놓은 List
 - 참고
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)] -> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    arr = [list(int(input()) for _ in range(N))] -> [[123], [456], [789]]
  *) i는 보통 행, j는 보통 열을 나타낼 때 씀

2차원 배열의 접근
  arr = [[1, 2, 3], [4, 5, 6]]
  row = len(arr)
  col = len(arr[0])

 - 행 우선 순회 방법
    for i in range(row):
        for j in range(col):
            print(arr[i][j])

 - 열 우선 순회 방법
    for j in range(col):
        for i in range(row):
            print(arr[i][j])

 - 지그재그 순회 -> 직접 해보고 이해해야 할 듯 (코드도 쳐보고)
    -> , <- , -> , <- ... 이렇게 순회하는 방법
    for i in range(row):
        for j in range(col):
            print(arr[i][j + (col-1-2*j) * (i%2)])

    <- , ->, <- , -> ... 이 방법도 구현 해보자

    if문 써서 i % 2 == 0 일 때랑, 아닐 때 나눠서 구현하면서 이해 먼저 하고 하는게 나을 듯
    강의도 다시 보기
    
 - 델타를 이용한 2차 배열 탐색 (아주 아주 중요 ! ! !)
  2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
  인덱스 (i, j)인 칸의 상하좌우 칸 (ni, nj)
  노트필기보기 + 강의 다시보기 + 구현해보기
  

2차원 배열의 활용
 - 전치 행렬
 - 참고 부분 노트 정리하기 (i, j 크기에 따라 접근하는 원소 비교, 2-i == j 에서 2는 N-1이다)


연습문제
 - 연습문제 1: 해보기
 - 연습문제 1-2 : 25개의 각 요소에 대해서 그 요소와 이웃한 요소와의 차의 절대값의 '합'을 구하시오 (오타고치기 합으로 고치기)

부분집합
 - 부분집합 생성하기 - 직접 생성해보기 20p
 - 21p 일단 읽어보기 (시험에 막 연산자의 뜻 물어보고 그렇게 까진 안한다고 하는데 읽고 이해하면 좋을 듯)
 - 22p 이해안되더라도 코드 복붙하고 결과보고 이해하는 연습하기
 - 연습문제 해보기 (부분집합 코드 복붙해서 해도댐)